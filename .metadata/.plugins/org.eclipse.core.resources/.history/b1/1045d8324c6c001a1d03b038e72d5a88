/*
 * generated by Xtext 2.20.0
 */
package dk.klevang.generator

import dk.klevang.mathInterpreter.Exp
import dk.klevang.mathInterpreter.MathExp
import dk.klevang.mathInterpreter.Minus
import dk.klevang.mathInterpreter.Plus
import dk.klevang.mathInterpreter.Mult
import dk.klevang.mathInterpreter.Div

import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import org.eclipse.xtext.ui.editor.hover.html.DefaultEObjectHoverProvider
import org.eclipse.emf.ecore.EObject
import java.util.HashMap

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathInterpreterGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		//System.out.println("Math expression = "+math.display)
		// For +1 score, replace with hovering, see Bettini Chapter 8
		JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def int compute(MathExp math) {
		
		val var_list = newHashMap
		if (math.exp === null)
		{
			//this is when we have a let binding followed by "in" ... "end" keywords
			val left = math.left.compute
			var_list.put(math.left.getMathVar.getExpVar, left)
			math.right.computeExp(var_list)
		}	
		else
		{
			//we have an ordinary let binding, e.g. "let x = 14" or "let x = 2+2"
			math.exp.computeExp(null)
		}
	}
	
	def int computeExp(Exp exp, HashMap<String, Integer> vars) {
		System.out.println(exp)
		System.out.println(exp.eContainer)
		
		if (exp.getExp !== null)
		{
			// this is for when the expression is "empty" and a parenthesis.
			// the computation continues on the current Exp's expression.
			return exp.getExp.computeExp(vars)
		}
		else if (exp.getMathExp !== null)
		{
			// this is for nested let bindings
			return exp.getMathExp.compute
		}
		val right = exp.right.computeBranch(vars)
		
		switch exp {
			Plus: exp.left.computeExp(vars) + right
			Minus: exp.left.computeExp(vars) - right
			Mult: exp.left.computeExp(vars) * right
			Div: exp.left.computeExp(vars) / right
			default: exp.computeBranch(vars)
		}
	}

	def int computeBranch(Exp exp, HashMap<String, Integer> vars)
	{
		if (exp !== null)
		{
			switch exp {
				Plus: return exp.computeExp(vars)
				Minus: return exp.computeExp(vars)
				Mult: return exp.computeExp(vars)
				Div: return exp.computeExp(vars)
				default: return exp.handleVariable(vars)
			}
		}
		return -1000

	}
	
	def int handleVariable(Exp exp, HashMap<String, Integer> vars)
	{
		if (exp.getExpVar() === null)
		{
			return exp.getValue()
		}
		else
		{
			val variable = vars.get(exp.getExpVar())
			return variable
		}
	}
	
	def int computeRightSide(Exp exp)
	{
		if (exp !== null)
		{
			System.out.print("Number: ")
			System.out.println(exp)
			return exp.getValue()
		}
		return -1000
		
	}

	//
	// Display function: show complete syntax tree
	// NAte: written according to illegal left-recursive grammar, requires fix
	//

	def CharSequence display(MathExp math) '''Math[쳋ath.exp.displayExp2]'''
	//def CharSequence displayExp(Exp exp) '''Exp[첿xp.left?.displayExp,첿xp?.displayOp,첿xp?.displayPrim(exp.right)]'''
	def CharSequence displayFactor(Exp primary) { "?" }
	def displayPrim(Exp parent, Exp child)
	{
		if (child === null)
		{
			parent.getValue()
		}
		else
		{
			child.getValue()
		}
		
	}
	def displayOp(Exp exp)
	{
		switch exp {
			Plus: "+"
			Minus: "-"
			Mult: "*"
			Div: "/"
		}
	}
	def CharSequence displayExp2(Exp exp)
	{
		if (exp.getExp() === null)
		{
			return '''Exp[첿xp.left?.displayExp2,첿xp?.displayOp,첿xp?.displayPrim(exp.right)]'''
		}
		else
		{
			return displayExp2(exp.getExp())
		}
	}
	

}
